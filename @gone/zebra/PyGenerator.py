from zebra import Generator, trim, indent
import types, string, re

###################################################
##[ zebra.PyGenerator ]############################
###################################################
class PyGenerator(Generator):

    def __init__(self):
        Generator.__init__(self)
        self.head = trim(
            """
            #
            # this file was generated by zebra
            #
            def fetch():
                _res = ""
            """)
        self.foot = trim(
            """
            # end of fetch()
                return _res
        
            def show():
                print fetch()
        
            if __name__=="__main__":
                show()
            """)

        self.initialDepth = 1 # because we're in a function
        self.depth = self.initialDepth #@TODO: put this in flatten()


    ## @TODO: this is all just cut and pasted from PHP3Generator. yuck. :/

    def flatten(self, stripeset, context="show"):
        """Converts a stripe or stripeset into a string"""

        res = ""
        if type(stripeset)!=types.ListType:
            stripeset = [stripeset]

        for stripe in stripeset:           
            stripehead  = stripebody  = stripefoot  = ""
            test = conditional = ""
            if type(stripe)==types.StringType:

                ## @TODO: WHY WAS I DOING THIS??
                ##
                ## I'm pretty sure this was just a hack for
                ## when o2x and the parser's handle_data
                ## were doing the wrong thing, and can safely
                ## be deleted now..
                ##
                #### strip leading and trailing newlines
                ##if stripe[0] == "\n":
                ##    stripe = stripe[1:]
                ##if stripe[-1] == "\n":
                ##    stripe = stripe[:-1]

                ## deal with context (we only care when it's a string)
                if (context == "show"):
                    # stripehead = "    " * depth + '_res = _res + "'
                    ## hmm.. i think that "    " * depth was a bad
                    ## idea because it got called over and over again..
                    ## in fact, now that I think about it... the
                    ## proper way to handle indentation is to simply
                    ## call indent (from ziketools.py), and let the
                    ## recursiveness of this function handle everything
                    ## else...
                    stripehead = indent('_res = _res + "')
                    stripebody = string.replace(
                        string.replace(stripe, '"', '\\"'),
                        "\n", "\\n")
                    stripefoot = '"\n'
                elif context == "exec":
                    stripebody = indent(stripe)
                    stripefoot = '\n'
                elif context == "clear":
                    stripebody = stripe
                else:
                    #@TODO: this should raise an error
                    pass

                # now that we know what it is, interpolate it..
                stripebody = self.interpolate(stripebody, context)

            elif type(stripe)==types.ListType:
                stripebody = self.flatten(stripe)
            elif type(stripe)==types.DictionaryType:
                # @TODO: this ought to all be stored in a
                # dictionary that maps tags to functions
                tag = stripe["tag"]
                if tag == "stripe":
                    stripebody = self.flatten(stripe["content"],
                                              stripe["context"])
                    test   = stripe["test"]
                    conditional = stripe["conditional"]
                elif tag == "report":
                    # report always starts a newline..
                    res = res + self.flatten_report(stripe)
                else:
                    raise "don't know how to flatten " + tag
            else:
                raise("unknown structure in stripe")

            ## finally, the conditional
            if (test):
                if not (conditional):
                    raise "Error: test without conditional?!?!?!"
                else:
                    # interpolate the test, so that we can do:
                    # * if test="{somefield}"
                    test = self.interpolate(test,"exec")

            if (conditional): # el has no condition

                conditionals = {"if":"if", "ef":"elif", "el":"else"}

                # indent the body...
                if conditional != "do":
                    stripebody = indent(stripebody)

                if conditional in ["if", "ef"]:
                    stripehead = stripehead \
                                 + conditionals[conditional] + " (" \
                                 + test + "):\n" \
                                 + stripehead
                elif conditional == "el":
                    stripehead = stripehead \
                                 + conditionals[conditional] + ":" \
                                 + stripehead

            # I used to have a \n on the end of this next bit,
            # but that's bad juju if you want to flatten something
            # INSIDE a python statement (eg, for report), so now
            # if you want to add a \n, add it explicitly:
            res = res + stripehead + stripebody + stripefoot
        
        return res

    ###############################################

    def flatten_report(self, report):

        # @TODO: this is one serious kludge.
        # @TODO: code each variable name with depth so can have nested reports

        res = ""

        ## first,  set up the datasource and query
        
        queryobj  = self.parsedict['queries'][report['query']]
        query = self.flatten(queryobj['query'], context="exec")
        source = self.parsedict['sources'][queryobj['source']]
        connector = self.flatten(source['connector'], context="exec")

        res = res + trim(
            """
            import %s
            %s = %s.connect("%s")
            %s = %s.cursor()
            %s.execute("%s")
            """ % (source['class'],
                   queryobj['source'], source['class'], connector,
                   report['query'], queryobj['source'],
                   report['query'], query
                   ))

        ## set up two arrays for handling groups:
        ##
        ## _groups contains the names of the grouping levels..
        ## There's always at least 1. The first, =top= is magical.
        ##
        ## _showFoot decides, for each row, whether to display footers.
        ## if we display an outer footer, we must display all the
        ## inner footers FIRST.. So setting _showFoot(x)=1 essentially
        ## sets each _showFoot(x+1..x+n) to 1, too..
        ## on the very last record, we want to show the big daddy
        ## footer for the whole report, and that's why we need =top=.

        res = res + "_groups=['=top='"
        
        buf = "_showFoot=[0"
        for g in report["groups"]:
            res = res + ", '" + g + "'"
            buf = buf + ",0"
        res = res + "]\n"
        res = res + buf + "]\n"

        ## _nomore tells us when we're about to
        ## hit the last record..
        ## _flds keeps track of the column names
        ## (cuz of how python's DB API works)
        res = res + trim(
            """
            _nomore = 0
            _flds = {}
            """)

        ## now we need to test whether there's
        ## any data in the recordset... in the
        ## PHP3 version, this actually called
        ## next_record(), in python that's just
        ## wrong.
        res = res + "if (" + report['query'] + ".rowcount > 0):\n"

        ##-- BEGIN IF ROWCOUNT > 0 --##
        
        ## if there ARE records, show the head:
        res = res + self.flatten(report["head"],"show")

        ## (still underneath "if ..rowcount > 0"...
        ## nr is next record, tr = this one, pr = previous
        ## we need to look at 3 records at once in order to
        ## know when to print the headers and footers..
        res = res + indent(trim("""
        _nr = %s.fetchone()
        _pr = []
        for _f in range(len(%s.description)):
            _flds[%s.description[_f][0]] = _f
            _pr.append(None)
        """ % (report['query'], # _nr = fetchone
               report['query'], # for _f
               report['query'], # _flds[...description
               )))

        ##-- END IF ROWCOUNT > 0 --##

        res = res + trim("""
        for _i in range(%s.rowcount):
            _tr = _nr
            _nr = %s.fetchone()
            if _nr == None:
                _nomore = 1
        """ % (report['query'], # for _i
               report['query'], # _nr = fetchone (again)
               ))

        ##-- BEGIN FOR I IN RANGE ROWCOUNT --##
        
        ## handle the grouping for the heads:
        for i in range(len(report["groups"])):
            if report["grouph"][i]:
                res = res + indent(trim("""
                if (_tr[_flds["%s"]] != _pr[_flds["%s"]]):
                %s
                """ % (report["groups"][i],
                       report["groups"][i],
                       indent(self.flatten(report["grouph"][i],"show")
                              ))))

        ## now the body:
        res = res + indent(self.flatten(report["body"],"show"))

        ## and the footers:
        res = res + indent(trim("""
        if (_nomore):
            _showFoot[0] = 1
        for _g in range(1, len(_showFoot)):
            if (_showFoot[_g-1]) \\
            or ((_nr[_flds[_groups[_g]]] != _tr[_flds[_groups[_g]]])):
                _showFoot[_g] = 1
            else:
                _showFoot[_g] = 0
        """))

        for i in range(len(report["groups"])):
            if report["groupf"][i]:
                res = res + indent(trim("""
                if (_showFoot[%s]):
                %s
                """ % (`i+1`,
                       indent(self.flatten(report["groupf"][i],"show")
                              ))))

        ##--END FOR I IN RANGE ROWCOUNT--##

        ## cap off the loop:
        res = res + indent(trim("""
        _pr = _tr
        """))

        ## and show the main footer:
        res = res + trim("""
        %s
        """ % self.flatten(report["foot"],"show"))

        ## handle "none"
        if report["none"]:
            res = res + indent(trim("""
            else:
            %s
            """ % self.flatten(report["none"],"show")))


        
        ## finally, encode variables with depth, so we can nest reports
##         reDepth = re.compile("(_\w+)", re.I | re.S )
##         res = reDepth.sub(r"\1_" + `depth`,res)

        return indent(res) #, self.depth)



    ###############################################


    def interpolate_field(self, field, context):
        res =  '_tr[_flds[\'' + field + '\']]'
        if context == "show":
            # escape out of quotes:
            res =  '" + ' + res + ' + "'
        return res

