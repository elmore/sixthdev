from zebra import Generator
from ziketools import trim, indent
import types, string, re

###################################################
##[ zebra.PyGenerator ]############################
###################################################
class PyGenerator(Generator):

    def __init__(self):
        self.head = trim("""
        #
        # this file was generated by zebra
        #
        def fetch():
            _res = ""
        """)
        self.foot = trim("""
        # end of fetch()
            return _res
        
        def show():
            print fetch()
        
        if __name__=="__main__":
            show()
        """)

        self.initialDepth = 1 # because we're in a function


    ## @TODO: this is all just cut and pasted from PHP3Generator. yuck. :/

    def flatten(self, stripeset, depth, context="show"):
        """Converts a stripe or stripeset into a string"""

        res = ""
        if type(stripeset)!=types.ListType:
            stripeset = [stripeset]

        for stripe in stripeset:           
            stripehead  = stripebody  = stripefoot  = ""
            test = conditional = ""
            if type(stripe)==types.StringType:
                ## @TODO: WHY WAS I DOING THIS??
                ##
                ## I'm pretty sure this was just a hack for
                ## when o2x and the parser's handle_data
                ## were doing the wrong thing, and can safely
                ## be deleted now..
                ##
                #### strip leading and trailing newlines
                ##if stripe[0] == "\n":
                ##    stripe = stripe[1:]
                ##if stripe[-1] == "\n":
                ##    stripe = stripe[:-1]
                
                ## deal with context (we only care when it's a string)
                if (context == "show"):
                    #stripehead = "    " * depth + '_res = _res + "'
                    # hmm.. i think that "    " * depth was a bad
                    # idea because it got called over and over again..
                    # in fact, now that I think about it... the
                    # proper way to handle indentation is to simply
                    # call indent (from ziketools.py), and let the
                    # recursiveness of this function handle everything
                    # else...
                    stripehead = '_res = _res + "'
                    stripebody = string.replace(
                        string.replace(stripe, '"', '\\"'),
                        "\n", "\\n")
                    stripefoot = '"\n'
                elif context == "exec":
                    stripebody = stripe
                else:
                    #@TODO: this should raise an error
                    pass
            elif type(stripe)==types.ListType:
                # stay at the same depth:
                stripebody = self.flatten(stripe,depth)
            elif type(stripe)==types.DictionaryType:
                # @TODO: this ought to all be stored in a
                # dictionary that maps tags to functions
                tag = stripe["tag"]
                if tag == "stripe":
                    stripebody = self.flatten(stripe["content"],depth,
                                              stripe["context"])
                    test   = stripe["test"]
                    conditional = stripe["conditional"]
                elif tag == "report":
                    # report always starts a newline..
                    res = res + self.flatten_report(stripe, depth)
                else:
                    print "*** don't know how to flatten " + tag
            else:
                raise("unknown structure in stripe")

            ## finally, the conditional
            if (test) and not (conditional):
                raise "Error: test without conditional?!?!?!"

            if (conditional): # el has no condition
                conditionals = {"if":"if", "ef":"elif", "el":"else"}

                # indent the body... 
                stripebody = indent(stripebody)

                if conditional in ["if", "ef"]:
                    stripehead = stripehead \
                                 + conditionals[conditional] + " (" \
                                 + test + "):\n" \
                                 + stripehead
                elif conditional == "el":
                    stripehead = stripehead \
                                 + conditionals[conditional] + ":" \
                                 + stripehead

            # I used to have a \n on the end of this next bit,
            # but that's bad juju if you want to flatten something
            # INSIDE a python statement (eg, for report), so now
            # if you want to add a \n, add it explicitly:
            res = res + stripehead + stripebody + stripefoot
        
        # now that we have the whole set, interpolate variables:
        res = self.reZVar.sub(self.interpolate, res)

        return res

    ###############################################

    def flatten_report(self, report, depth=0):

        # @TODO: this is one serious kludge.
        # @TODO: code each variable name with depth so can have nested reports

        res = ""

        ## first,  set up the datasource and query
        
        queryobj  = self.parsedict['queries'][report['query']]
        query = self.flatten(queryobj['query'], depth, context="exec")
        source = self.parsedict['sources'][queryobj['source']]
        connector = self.flatten(source['connector'], depth, context="exec")

        res = res + trim("""
        import %s
        %s = %s.connect("%s")
        %s = %s.cursor()
        %s.execute("%s")
        """ % (source['class'],
               queryobj['source'], source['class'], connector,
               report['query'], queryobj['source'],
               report['query'], query
               ))

        ## set up two arrays for handling groups:
        ##
        ## _groups contains the names of the grouping levels..
        ## There's always at least 1. The first, =top= is magical.
        ##
        ## _showFoot decides, for each row, whether to display footers.
        ## if we display an outer footer, we must display all the
        ## inner footers FIRST.. So setting _showFoot(x)=1 essentially
        ## sets each _showFoot(x+1..x+n) to 1, too..
        ## on the very last record, we want to show the big daddy
        ## footer for the whole report, and that's why we need =top=.

        res = res + "_groups=['=top='"
        
        buf = "_showFoot=[0"
        for g in report["groups"]:
            res = res + ", '" + g + "'"
            buf = buf + ",0"
        res = res + "]\n"
        res = res + buf + "]\n"

        ## _nomore tells us when we're about to
        ## hit the last record..
        ## _flds keeps track of the column names
        ## (cuz of how python's DB API works)
        res = res + trim("""
        _nomore = 0
        _flds = {}
        """)

        ## now we need to test whether there's
        ## any data in the recordset... in the
        ## PHP3 version, this actually called
        ## next_record(), in python that's just
        ## wrong.
        res = res + "if (" + report['query'] + ".rowcount > 0):\n"

        ##-- BEGIN IF ROWCOUNT > 0 --##
        
        ## if there ARE records, show the head:
        res = res + indent(self.flatten(report["head"],depth,"show"))

        ## (still underneath "if ..rowcount > 0"...
        ## nr is next record, tr = this one, pr = previous
        ## we need to look at 3 records at once in order to
        ## know when to print the headers and footers..
        res = res + indent(trim("""
        _nr = %s.fetchone()
        _pr = []
        for _f in range(len(%s.description)):
            _flds[%s.description[_f][0]] = _f
            _pr.append(None)
        """ % (report['query'], # _nr = fetchone
               report['query'], # for _f
               report['query'], # _flds[...description
               )))

        ##-- END IF ROWCOUNT > 0 --##

        res = res + trim("""
        for _i in range(%s.rowcount):
            _tr = _nr
            _nr = %s.fetchone()
            if _nr == None:
                _nomore = 1
        """ % (report['query'], # for _i
               report['query'], # _nr = fetchone (again)
               ))

        ##-- BEGIN FOR I IN RANGE ROWCOUNT --##
        
        ## handle the grouping for the heads:
        for i in range(len(report["groups"])):
            if report["grouph"][i]:
                res = res + indent(trim("""
                if (_tr[_flds["%s"]] != _pr[_flds["%s"]]):
                %s
                """ % (report["groups"][i],
                       report["groups"][i],
                       indent(self.flatten(report["grouph"][i],depth,"show")))))

        ## now the body:
        res = res + indent(self.flatten(report["body"],depth,"show"))

        ## and the footers:
        res = res + indent(trim("""
        if (_nomore):
            _showFoot[0] = 1
        for _g in range(1, len(_showFoot)):
            if (_showFoot[_g-1]) \\
            or ((_nr[_flds[_groups[_g]]] != _tr[_flds[_groups[_g]]])):
                _showFoot[_g] = 1
            else:
                _showFoot[_g] = 0
        """))

        for i in range(len(report["groups"])):
            print ":::" + `report["groupf"][i]` + ":::"
            if report["groupf"][i]:
                res = res + indent(trim("""
                if (_showFoot[%s]):
                %s
                """ % (`i+1`, indent(self.flatten(report["groupf"][i],depth,"show")))))

        ##--END FOR I IN RANGE ROWCOUNT--##

        ## cap off the loop, show the foot...
        res = res + trim("""
        _pr = _tr
        %s
        """ % self.flatten(report["foot"],depth,"show"))

        ## handle "none"
        if report["none"]:
            res = res + indent(trim("""
            else:
            %s
            """ % self.flatten(report["none"],depth,"show")))


        
        ## finally, encode variables with depth, so we can nest reports
##         reDepth = re.compile("(_\w+)", re.I | re.S )
##         res = reDepth.sub(r"\1_" + `depth`,res)

        return indent(res, depth)



    ###############################################

    def interpolate(self, match):

        """replaces {fields}, {$vars} and {!inserts}
        in a flattened zebra stripeset..."""

        #@TODO: this is all hard-coded for PHP3. make it generic.
        #@TODO: interpolation needs to be table driven so that
        # we can translate into different languages
        # (or maybe an overridable function?)
        # also, it ought to be per-stripe (and only used on stripe
        # bodies and conditionals)
        # .. that way, we can change interpolation as context changes.

        token = match.group(1)
        if token[0]=="!":
            if self.named.has_key(token[1:]):
                # context="exec" so you don't get: print "print"whatever""
                # @TODO: maybe have a "passthru" context, as some
                # languages might alter "exec"?
                # (eg, php3 mode might one day use "<?" and  "?>"
                return self.flatten(self.named[token[1:]], context="exec")
            else:
                return ""
        elif token[0] == "$":
            return token
        else:
            # fields.. there needs to be a standard
            # way of doing this per language.
            # in python's case, we have to escape out of the
            # string...
            # @TODO: document which quotes to use where.. 
            return '" + _tr[_flds[\'' + token + '\']] + "';

